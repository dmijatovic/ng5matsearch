//Angular
import {Injectable} from '@angular/core';

//RxJs
import { Observable } from 'rxjs/Observable';
import { Subject } from 'rxjs/Subject';
import { BehaviorSubject } from 'rxjs/BehaviorSubject';

/**
 * Managing drag and drop events to create filter conditions
 */
@Injectable()
export class DragDropConditionsService{

  constructor(){
    console.log("DragDropService...started");
  }

  masterOperator:string="AND";
  mo = new BehaviorSubject<string>(this.masterOperator);
  masterOperator$ = this.mo.asObservable();
  setMasterOperator(mo){
    this.masterOperator = mo;
    this.mo.next(mo);
  }

  groups:any=[];
  grp = new BehaviorSubject<any>(this.groups)
  groups$ = this.grp.asObservable();

  /**
   * Create new group, first condition 
   * of new group is provided
   * @param cond 
   */
  addGroup({operator, conditions}){
    let ngr= {
      gid: this.createUid(),
      operator: operator,
      conditions: conditions
    };
    //add to local collection
    this.groups.push(ngr);
    //publish updated groups collection
    this.grp.next(this.groups);
  }

  updateGroup({gid, data}){
    console.log("Edit group...", gid, data);
    //debugger 
    //get group position
    let gpos =this.getConditioGroupPos(gid);
    
    //create new object
    let all = [
      ...this.groups.slice(0,gpos),
      data,
      ...this.groups.slice(gpos+1)
    ]

    //update local object 
    this.groups = all;
    //update all 
    this.grp.next(all);
    
  }
  /**
   * Remove condition group from collection
   * @param gid 
   */
  deleteConditionGroup(gid){
     //create new array with valid items
    let gr = this.groups.filter((g)=>{
      return g.gid != gid;
    });
    //overwrite with new
    this.groups = gr;
    //emit new data
    this.grp.next(gr);
  }
  /**
   * Returns new object with the condition group data (no refrence)
   * @param gid 
   */
  getConditionGroup(gid){
    let gr = this.groups.filter(g => g.gid === gid);
    if (gr.length==1){
      return gr[0];
    }else{
      return null;
    }
  }
  /**
   * Get position of condition group in the array
   * for purpose of replacing old data with new data
   * @param gid : group unique id, generated by service
   */
  getConditioGroupPos(gid){
    let id = -1;
    for (let i=0; i < this.groups.length; i++){
      let g = this.groups[i];
      if (g.gid === gid){
        //id = i;
        return i;
      }
    }
    return null;
  }
//--------------------------------------------  
// CONDITIONS -> OPERATIONS
// WITHIN ONE CONDITION GROUP
  /**
   * Add new condition object to collection
   * @param cond 
   */

  conditions:any=[];
  cond = new BehaviorSubject<any>(this.conditions)
  conditions$ = this.cond.asObservable();
  
  /**
   * Add new condition to specific group
   * @param data = {
   *  gid: unique group id,
   *  condition:{ new condition object }
   * }
   */
  addCondition(data){
    //get condition group we want to mutate
    let cg = this.getConditionGroup(data.gid);
    //add new condition to it
    cg.conditions.push(data.condition);
    //return group with
    return cg;
  }
  /**
   * Replace existing object with newone
   * @param cond 
   */
  updateCondition(cond){
    let id = getId();
    
    if (id){
      console.log("found condition item to update");
    }

    //child function to find item by id
    function getId(){
      let id = -1;
      for (let i=0; i < this.conditions.length; i++){
        let c = this.conditions[i];
        if (c.cid === cond.cid){
          //id = i;
          return i;
        }
      }
      return null;
    }
  }
  /**
   * Remove condition object with this def
   * @param id 
   */
  deleteCondition(gid, cid){
    //create new array with valid items
    //debugger
    let gr = this.getConditionGroup(gid);
    let cl = gr.conditions.filter((c)=>{
      return c.cid != cid;
    });
    
    //overwrite with new
    gr.conditions = cl;
    
    //return group
    return gr;
  }

  //function for creating unique id
  //used for component referrence
  //when deleting
  createUid() {
    //we base uid on unique time creation
    //and remove spaces, comas etc.
    let timestamp = new Date()
      .toUTCString()
      .replace(/ |,|;|:/g, "")
      .toLowerCase();
    //add random number to it
    timestamp += Math.round(Math.random() * 100000);
    return timestamp;
  }
}


/**
 * Drag and drop source field service 
 * gets the possible fields to drag and drop 
 * 
 */
@Injectable()
export class DragDropFieldsService{
  constructor(){
    //console.log("DragDropSourceDataService...started");
  }
  
  getFields(){

    return new Observable((observer)=>{

      observer.next([
        {id:'f1', label:"Field 1", operators:["=","<",">","IN"], type:'number', group:'group 1'},
        {id:'f2', label:"Field 2", operators:["=","<",">","IN"], type:'number', group:'group 1'},
        {id:'f3', label:"Field 3", operators:["=","<",">","IN"], type:'number', group:'group 1'},
        {id:'f4', label:"Field 4", operators:["=","<",">","IN"], type:'number', group:'group 1'}
      ]);

      observer.complete();
    });
  }
}